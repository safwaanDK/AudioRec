import {
    $query,
    $update,
    blob,
    ic,
    Opt,
    Principal,
    Record,
    Result,
    StableBTreeMap,
    Variant,
    Vec,
    nat64,
    match
  } from 'azle';
  import { v4 as uuidv4 } from "uuid";
  
  // Define the User structure
  type User = Record<{
    id: string;
    principal: Principal;
    createdAt: nat64;
    recordingIds: Vec<string>;
    username: string;
  }>;
  
  // Define the Recording structure
  type Recording = Record<{
    id: string;
    audio: blob;
    createdAt: nat64;
    name: string;
    userId: string;
  }>;
  
  // Define the AudioRecorderError structure
  type AudioRecorderError = Variant<{
    RecordingDoesNotExist: string;
    UserDoesNotExist: string;
    InvalidPayload: string;
    Error: string;
  }>;
  
  // Initialize the users and recordings storage
  const users = new StableBTreeMap<string, User>(0, 44, 1024);
  const recordings = new StableBTreeMap<string, Recording>(1, 44, 1024);

  // Helper function that trims the input string and then checks the length
  // The string is empty if true is returned, otherwise, string is a valid value
  function isInvalidString(str: string): boolean {
    return str.trim().length == 0
  }

  // Helper function to ensure the input id meets the format used for ids generated by uuid
  function isValidUuid(id: string): boolean {
    const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
    return regexExp.test(id);
  }
  
  
  
  $update
  export function createUser(username: string): Result<User, AudioRecorderError> {
    try {
      // Payload validation
      if (isInvalidString(username)) {
        return Result.Err({InvalidPayload: `Username=${username} cannot be empty.`});
      }
  
      const id = uuidv4();
      const user: User = {
        id,
        principal: ic.caller(),
        createdAt: ic.time(),
        recordingIds: [],
        username,
      };
  
      users.insert(user.id, user);
  
      return Result.Ok(user);
    } catch (error) {
      // Error handling
      return Result.Err({Error: `Failed to create user: ${error}`});
    }
  }
  
  $query
  export function readUsers(): Result<Vec<User>, AudioRecorderError> {
    try {
      // Return user values
      return Result.Ok<Vec<User>, AudioRecorderError>(users.values());
    } catch (error: any) {
      // Error handling
      return Result.Err<Vec<User>, AudioRecorderError>({Error: 'Failed to retrieve users'});
    }
  }
  
  $query
  export function readUserById(id: string): Result<User, AudioRecorderError> {
    // Payload validation
    if (!isValidUuid(id)) {
      return Result.Err({InvalidPayload: `id=${id} is not in the valid uuid format.`});
    }
  
    return match(users.get(id), {
      Some: (user) => Result.Ok<User, AudioRecorderError>(user),
      None: () => Result.Err<User, AudioRecorderError>({UserDoesNotExist: `User with ID=${id} not found.`}),
    });
  }
  
  $update
  export function deleteUser(id: string): Result<User, AudioRecorderError> {
  
    // Payload validation
    if (!isValidUuid(id)) {
      return Result.Err({InvalidPayload: `id=${id} is not in the valid uuid format.`});
    }
  
    return match(users.get(id), {
      Some: (user) => {
        if (user.principal.toString() !== ic.caller().toString()){
          return Result.Err<User, AudioRecorderError>({Error: "Caller is not the principal of the user."})
        }
        // Delete associated recordings
        user.recordingIds.forEach((recordingId) => {
          recordings.remove(recordingId);
        });
  
        // Remove the user
        users.remove(user.id);
  
        return Result.Ok<User, AudioRecorderError>(user);
      },
      None: () => Result.Err<User, AudioRecorderError>({ UserDoesNotExist: `User with ID=${id} not found.` }),
    });
  }
  
  $update
  export function createRecording(
    audio: blob,
    name: string,
    userId: string
  ): Result<Recording, AudioRecorderError> {
    // Payload validation
    if (!isValidUuid(userId)) {
      return Result.Err({InvalidPayload: `userId=${userId} is not in the valid uuid format.`});
    }
  
    // Payload validation
    if (!audio.length || isInvalidString(name)) {
      return Result.Err({InvalidPayload: `Input data cannot contain empty values. Payload={audio:${audio}, name:${name}}`});
    }
  
    return match(users.get(userId), {
      Some: (user) => {
        if (user.principal.toString() !== ic.caller().toString()){
          return Result.Err<Recording, AudioRecorderError>({Error: "Caller is not the principal of the user."})
        }
        const id = uuidv4();
        const recording: Recording = {
          id,
          audio,
          createdAt: ic.time(),
          name,
          userId,
        };
  
        // Insert recording
        recordings.insert(recording.id, recording);
  
        // Update user's recordingIds
        const updatedUser: User = {
          ...user,
          recordingIds: [...user.recordingIds, recording.id],
        };
  
        users.insert(updatedUser.id, updatedUser);
  
        return Result.Ok<Recording, AudioRecorderError>(recording);
      },
      None: () => Result.Err<Recording, AudioRecorderError>({ UserDoesNotExist: userId }),
    });
  }
  
  $query
  export function readRecordings(): Result<Vec<Recording>, AudioRecorderError> {
    try {
      // Return recording values
      return Result.Ok(recordings.values());
    } catch (error: any) {
      // Error handling
      return Result.Err<Vec<Recording>, AudioRecorderError>({Error: `Failed to retrieve recordings: ${error}`});
    }
  }
  
  $query
  export function readRecordingById(id: string): Result<Recording, AudioRecorderError> {
    // Payload validation
    if (!isValidUuid(id)) {
      return Result.Err({InvalidPayload: `id=${id} is not in the valid uuid format.`});
    }
  
    return match(recordings.get(id), {
      Some: (recording) => Result.Ok<Recording, AudioRecorderError>(recording),
      None: () => Result.Err<Recording, AudioRecorderError>({RecordingDoesNotExist: `Recording with ID=${id} not found.`}),
    });
  }
  
  $update
  export function deleteRecording(id: string): Result<Recording, AudioRecorderError> {
    // Payload validation
    if (!isValidUuid(id)) {
      return Result.Err({InvalidPayload: `id=${id} is not in the valid uuid format.`});
    }
  
    const recordingOpt = recordings.get(id);
  
    return match(recordingOpt, {
      Some: (recording) => {
        const userOpt = users.get(recording.userId);
  
        return match(userOpt, {
          Some: (user) => {
            if (user.principal.toString() !== ic.caller().toString()){
              return Result.Err<Recording, AudioRecorderError>({Error: "Caller is not the principal of the user."})
            }
            // Update user's recordingIds
            const updatedUser: User = {
              ...user,
              recordingIds: user.recordingIds.filter(
                (recordingId) => recordingId !== recording.id
              ),
            };
  
            users.insert(updatedUser.id, updatedUser);
  
            // Remove recording
            recordings.remove(id);
  
            return Result.Ok<Recording, AudioRecorderError>(recording);
          },
          None: () => Result.Err<Recording, AudioRecorderError>({
            UserDoesNotExist: `User with id=${recording.userId} not found.`,
          }),
        });
      },
      None: () => Result.Err<Recording, AudioRecorderError>({
        RecordingDoesNotExist: `Recording with id=${id} not found.`,
      }),
    });
  }
  
  globalThis.crypto = {
    //@ts-ignore
    getRandomValues: () => {
      let array = new Uint8Array(32);
  
      for (let i = 0; i < array.length; i++) {
        array[i] = Math.floor(Math.random() * 256);
      }
  
      return array;
    },
  };
  